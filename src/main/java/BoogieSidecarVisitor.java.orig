import java.util.HashMap;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;

import com.microsoft.z3.ArithExpr;
import com.microsoft.z3.BoolExpr;
import com.microsoft.z3.Expr;
import com.microsoft.z3.Solver;
import com.microsoft.z3.Sort;

import grammar.BoogieGrammar;
import grammar.ConcreteInput;
import grammar.Symbol;
import parser.ASTNode;
import semantics.SemanticEvaluationException;
import semantics.SemanticVisitor;

public class BoogieSidecarVisitor extends SemanticVisitor<Expr> { // probably switch String to some VC representation later


	private boolean DEVEL = true;
	private final Semaphore semaphore = new Semaphore(1);
	private Sort int_type;
	private static AtomicInteger variable_counter = new AtomicInteger(1);
	private static Solver solver;
	private HashMap<String, Expr> globalVariables;
	private HashMap<Expr, String> freshVarToRealVar; // is mapped freshvar -> real variable, e.g. t7 to p
	public int nodesVisited = 0;
	
	public TestMain testSuite = null;
	
	public BoogieSidecarVisitor(int visitorId) {
		super(visitorId);
		if(TestMain.solver == null) {
			TestMain.solver = TestMain.context.mkSolver();
		}
		solver = TestMain.solver;
		globalVariables = new HashMap<String, Expr>();
		freshVarToRealVar = new HashMap<Expr, String>();
		int_type = TestMain.context.getIntSort();
		System.out.println("ANOTHER VISITOR");

        long threadId = Thread.currentThread().getId();
        System.out.println("I am thread " + threadId + " of ");
		// TODO Auto-generated constructor stub
	}
	
	private synchronized String freshVar() {
		return "t"+variable_counter.getAndIncrement();// +variable_counter;
	}
	
	private String extractVariable(ASTNode node) { 
		// A bit of a hack since computeInitialValue cant be used to extract variable names, I'll just use this instead from representation()
		int splitpos = node.representation().indexOf('[');
		return node.representation().substring(0,splitpos);
	}
	
	public static BoogieSidecarVisitor newVisitor(){
		return new BoogieSidecarVisitor(SemanticVisitor.getUniqueVisitorId());
	}

	@Override
	protected Expr computeInitialValue(ConcreteInput arg0) throws SemanticEvaluationException {
		if(arg0.getCorrespondingTerminal().equals(BoogieGrammar.getInstance().int_)){
			// return arg0.getRepresentation();
			// A bit of a hack...should probably change grammar. Now this can be triggered from "int" and numbers requiring this hack
			// Not sure what to do with "int" atm
//			System.out.println("INT MEKK: " + arg0.getRepresentation());
			if(arg0.getRepresentation().matches("\\d+")) {
				return TestMain.context.mkInt(Integer.parseInt(arg0.getRepresentation()));
			}
			// 
		} else if(arg0.getCorrespondingTerminal().equals(BoogieGrammar.getInstance().id)) {
			// For now lets use this place to add ID's to the pool. Everything is treated as global var for now - TODO CHANGE
			// NOTE: Ended up being wrong, since id is used in several places. Bad practice.
//			String freshvar = freshVar();
//			if(TestMain.DEBUG) {
//				System.out.println("ID: "+ arg0.getRepresentation()+" added as variable " +freshvar);
//			}
//			variables.put(arg0.getRepresentation(), freshvar);
			
		}
		// return arg0.getRepresentation();
		return null; // TODO: feels wrong? possibly do something like above with more cases
//		return "[!!!Undefined computeInitialValue!!! "+arg0.getRepresentation()+"]";
	}
	

	@Override
	protected Expr visit(ASTNode arg0) throws SemanticEvaluationException {
		nodesVisited++;
		try {
			semaphore.acquire();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		BoogieGrammar bg = BoogieGrammar.getInstance();
		Symbol symbol = arg0.getSymbol();
		List<ASTNode> children = arg0.getChildren();
		Expr result = null;
		
		if (symbol.equals(bg.ntVarDecl)) {
			Expr var = getValue(children.get(1));
			result = var;
		} else if(symbol.equals(bg.ntDecl)){
//			System.out.println("NTDECL");
			result = getValue(children.get(0));

		} else if (symbol.equals(bg.ntStmtList)){
				// Assignment
			

			
			
			if(children.get(0).getSymbol().equals(bg.ntLhs)) {
			    // Assignment
			    Expr lhs = getValue(children.get(0));
			    Expr rhs = getValue(children.get(2));
			    BoolExpr eq = TestMain.context.mkEq(lhs,rhs);
//				BoolExpr eqNot = TestMain.context.mkNot(eq);
				BoolExpr versionControl = eq; // used to be eq
				result = versionControl;
//				TestMain.solver.add(versionControl);
				if(children.size() != 4 && getValue(children.get(4)) != null) {
//			     BoolExpr andNext = TestMain.context.mkAnd(versionControl, (BoolExpr)(getValue(children.get(4))));
//			     result = andNext;
//					result = getValue(children.get(4));

			    }
			    
			   } else if (children.get(1).getSymbol().equals(bg.ntIfStmt)) {
				result = getValue(children.get(1));
			}  			} else if (children.get(0).getSymbol().equals(bg.call)) {
				// gbh.addProduction(ntStmtList, call, id, call, leftParanthesis, rightParanthesis, ntCallSpec, semicolon); // todo: add ntExprCommaList
				
				BoolExpr postconds = (BoolExpr) getValue(children.get(5));
				result = postconds;
				if(children.size() == 8) {
					BoolExpr next = (BoolExpr)getValue(children.get(7));
					result = TestMain.context.mkAnd((BoolExpr) result, next);
				}
			} else if (children.get(0).getSymbol().equals(bg.assert_)) {
				result = getValue(children.get(1));
				if(children.size() == 4) {
					BoolExpr next = (BoolExpr)getValue(children.get(3));
					result = TestMain.context.mkAnd((BoolExpr)result, next);
				}
			} else {
				System.out.println("UNKNOWN ntStmtList "+children.get(0));
			}
		} else if (symbol.equals(bg.ntCallSpec)){
			// gbh.addProduction(ntCallSpec, dotpostconditions, ntSpec, dotpreconditions, ntSpec, dotspecend);
			for(ASTNode child : children) {
				if(child.getSymbol().equals(bg.ntSpec)) {
					if(result == null) {
						result = getValue(child);
					} else {
						result = TestMain.context.mkAnd((BoolExpr) result, (BoolExpr) getValue(child));
					}
				}
				}
			} else if (children.get(0).getSymbol().equals(bg.while_)){
				if(children.size() == 16){
					if (DEVEL){
						System.out.println("Sidecar Parsing While-Loop");
					}
					
					BoolExpr initiation = (BoolExpr) getValue(children.get(1));
					
					BoolExpr assumption = TestMain.context.mkAnd((BoolExpr) getValue(children.get(5)), (BoolExpr) getValue(children.get(3)));
					BoolExpr whileBodyEvaluation = (BoolExpr) getValue(children.get(7));
					BoolExpr postBodyInvarEval = (BoolExpr) getValue(children.get(9));
					BoolExpr implRHS = (BoolExpr) TestMain.context.mkAnd(whileBodyEvaluation, postBodyInvarEval);
					BoolExpr consecution = TestMain.context.mkImplies(assumption, implRHS);
					//BoolExpr consecution = TestMain.context.mkAnd(assumption, postBodyInvarEval);
					
					BoolExpr assumptionBodyCont = TestMain.context.mkAnd((BoolExpr) getValue(children.get(11)), TestMain.context.mkNot( (BoolExpr) getValue(children.get(13))));
					BoolExpr continuedExecution = (BoolExpr) getValue(children.get(15));
					BoolExpr continuation = TestMain.context.mkImplies(assumptionBodyCont, continuedExecution);
					
					BoolExpr whileEvalation = TestMain.context.mkAnd(initiation, consecution, continuation);
					
					result = whileEvalation;
				} else{
					BoolExpr initiation = (BoolExpr) getValue(children.get(1));
					
					BoolExpr assumption = TestMain.context.mkAnd((BoolExpr) getValue(children.get(5)), (BoolExpr) getValue(children.get(3)));
					BoolExpr whileBodyEvaluation = (BoolExpr) getValue(children.get(7));
					BoolExpr postBodyInvarEval = (BoolExpr) getValue(children.get(9));
					BoolExpr implRHS = (BoolExpr) TestMain.context.mkAnd(whileBodyEvaluation, postBodyInvarEval);
					BoolExpr consecution = TestMain.context.mkImplies(assumption, implRHS);
					
					BoolExpr assumptionBodyCont = TestMain.context.mkAnd((BoolExpr) getValue(children.get(11)), TestMain.context.mkNot( (BoolExpr) getValue(children.get(13))));
					BoolExpr whileEvalation = TestMain.context.mkAnd(initiation, consecution, assumptionBodyCont);
					
					result = whileEvalation;
				}
				
			}
		} else if (symbol.equals(bg.ntLoopInv)){
			Expr expr = getValue(children.get(1)); 
			result = expr;
		} else if (symbol.equals(bg.ntIte)) {
			// gbh.addProduction(ntIte, itedot, ntExpr, id, id, itedotend);
			BoolExpr cond = (BoolExpr)getValue(children.get(1));
			Expr arg1 = TestMain.context.mkIntConst(extractVariable(children.get(2))); //TODO: Make more general
			Expr arg2;
			if(children.get(3).getSymbol().equals(bg.id)) {
				arg2 = TestMain.context.mkIntConst(extractVariable(children.get(3)));
			} else {
				arg2 = getValue(children.get(3));
			}
//			System.out.println("NTITE c:" +cond);
//			System.out.println("NTITE 1:" +arg2);
//			System.out.println("NTITE 2:" +extractVariable(children.get(3)));
			result = TestMain.context.mkITE(cond, arg1, arg2);
			
		} else if (symbol.equals(bg.ntIfStmt)) {
			System.out.println("IFSTMT, size: "+children.size());
			// OLD: 'if' '(' expr ')' '{' stmtList '}' #StmtIf1, size
			// NEW: gbh.addProduction(ntIfStmt, if_, leftParanthesis, ntExpr, rightParanthesis, leftCurlybracket, ntStmtList, dotifelsedelimiter, ntStmtList, rightCurlybracket); // for else-cases
			BoolExpr cond = (BoolExpr)getValue(children.get(2));
			BoolExpr bodyTrue = (BoolExpr)getValue(children.get(5));
			BoolExpr leftHalf = TestMain.context.mkImplies(cond, bodyTrue);
			if(children.get(7).getSymbol().equals(bg.ntStmtList)) {
				BoolExpr rest = (BoolExpr)getValue(children.get(7)); 
				result = TestMain.context.mkAnd(leftHalf,rest);
			} else {
				// Must be an else case:
				BoolExpr bodyFalse = (BoolExpr)getValue(children.get(9));
				BoolExpr rightHalf = TestMain.context.mkImplies(TestMain.context.mkNot(cond), bodyFalse);
				BoolExpr fullIf = TestMain.context.mkAnd(leftHalf, rightHalf);
				result = fullIf;
				if(children.size() == 12) {
					BoolExpr next = (BoolExpr)getValue(children.get(11));
					result = TestMain.context.mkAnd((BoolExpr)result, next);
				}
			}

			// 'if' '(' expr ')' '{' stmtList '}' else_ #StmtIf2 Has not been tested properly
			// 'if' '(' expr ')' '{' stmtList '}' stmtList #StmtIf3
		} else if (symbol.equals(bg.ntProcedureDecl)) {
//	    	gbh.addProduction(ntProcedureDecl, procedure, id, ntPSig, dot, dotnull, leftCurlybracket, ntStmtList, rightCurlybracket, ntSpec, procdot); 
//	    	gbh.addProduction(ntProcedureDecl, procedure, id, ntPSig, dot, ntSpec, leftCurlybracket, ntStmtList, rightCurlybracket, ntSpec, procdot);
//			System.out.println("PROCDECL "+children.get(1).representation());
			String procName = extractVariable(children.get(1));
			testSuite.registerProcedure(procName);
			BoolExpr version = TestMain.context.mkBoolConst(testSuite.getVersion());
			BoolExpr assignments = (BoolExpr) getValue(children.get(6));
			if (assignments != null ) {
				assignments = TestMain.context.mkImplies(version, assignments);
				solver.add(assignments);
			} 
			BoolExpr body = (BoolExpr) getValue(children.get(8));
			body = TestMain.context.mkNot(body);
			BoolExpr postconds = null; //(BoolExpr) getValue(children.get(8));
			BoolExpr proc;
			if(postconds != null) {
				proc = TestMain.context.mkAnd(body, postconds);
			} else {
				proc = body;
			}
			proc = TestMain.context.mkImplies(version, proc);
			solver.add(proc);
		} else if (symbol.equals(bg.ntSpec)) {
			
			Symbol type = children.get(0).getSymbol();
			
			if(type.equals(bg.requires) || type.equals(bg.ensures)) {
				result = getValue(children.get(1));

				if(children.size() == 4) {
					BoolExpr nextSpec = (BoolExpr) getValue(children.get(3));
					if(nextSpec != null) {
						result = TestMain.context.mkAnd((BoolExpr)result, nextSpec);
					}
				}

//				BoolExpr version = TestMain.context.mkBoolConst(testSuite.getVersion());
//				result = TestMain.context.mkImplies(version, (BoolExpr)result);
			}
		} else if (symbol.equals(bg.ntLhs)) {
			if(children.size() == 2) {
				String varname = extractVariable(children.get(1));
				Expr var;

				// We only support int and bool
				if(children.get(0).getSymbol().equals(bg.typeflag_int)) {
					var = TestMain.context.mkIntConst(varname);
				} else {
					var = TestMain.context.mkBoolConst(varname);
				}
				freshVarToRealVar.put(var, varname); // probably map the other way arround as well, TODO
				result = var;
			} else {
				System.out.println("LHSERROR");
			}
		}  
		
		
		
		
//		}
//		
//		
//		//
//		// EXPRESSIONS
//		//
		else if (symbol.equals(bg.ntExpr)) {
			if(arg0.getChildren().size() == 2) {
				result = getValue(children.get(1));
			}
		} else if (symbol.equals(bg.ntE0)) {
			if(arg0.getChildren().size() == 2) {
				result = getValue(children.get(1));
			}
		} else if (symbol.equals(bg.ntE1)) {
			if(arg0.getChildren().size() == 2) {
				result = getValue(children.get(1));
			}
		} else if (symbol.equals(bg.ntE2)) {
			if(arg0.getChildren().size() == 2) {
				result = getValue(children.get(1));
			} else if (children.get(1).getSymbol().equals(bg.orop)){
				BoolExpr left = (BoolExpr)getValue(children.get(0));
				BoolExpr right = (BoolExpr)getValue(children.get(2));
				result = TestMain.context.mkOr(left, right);
			} else if (children.get(1).getSymbol().equals(bg.andop)){
				BoolExpr left = (BoolExpr)getValue(children.get(0));
				BoolExpr right = (BoolExpr)getValue(children.get(2));
				result = TestMain.context.mkAnd(left, right);
			}
		} else if (symbol.equals(bg.ntE3)){
			if(arg0.getChildren().size() == 2) {
				result = getValue(children.get(1));
			} else if (children.get(1).getSymbol().equals(bg.relopEq)) {
				result = TestMain.context.mkEq(getValue(children.get(0)), getValue(children.get(2)));
				
			} else if (children.get(1).getSymbol().equals(bg.relopLessThan)) {
				System.out.println("RELOPLT");
				result = TestMain.context.mkLt((ArithExpr)getValue(children.get(0)), (ArithExpr)getValue(children.get(2)));
				
			} else if (children.get(1).getSymbol().equals(bg.relopGreaterThan)) {
				System.out.println("RELOPGT");
				result = TestMain.context.mkGt((ArithExpr)getValue(children.get(0)), (ArithExpr)getValue(children.get(2)));
				
			} else if (children.get(1).getSymbol().equals(bg.relopNotEq)) {
				System.out.println("RELOPNEQ");
				result =TestMain.context.mkEq(getValue(children.get(0)), getValue(children.get(2)));
				result = TestMain.context.mkNot((BoolExpr) result);
				
			} else if (children.get(1).getSymbol().equals(bg.relopEqOrLess)) {
				System.out.println("RELOPLTEQ");
				result = TestMain.context.mkLe((ArithExpr)getValue(children.get(0)), (ArithExpr)getValue(children.get(2)));
				
			} else if (children.get(1).getSymbol().equals(bg.relopEqOrGreater)) {
				System.out.println("RELOPGTEQ");
				result = TestMain.context.mkGe((ArithExpr)getValue(children.get(0)), (ArithExpr)getValue(children.get(2)));
				
			} else{
				System.out.println("RELOPUNKNOWN  "+children.get(1).getSymbol());
			}
		} else if (symbol.equals(bg.ntE5)){
			if(children.size() == 2) {
				result = getValue(children.get(1));
			} else if (children.get(1).getSymbol().equals(bg.addopPlus)){
				ArithExpr left = (ArithExpr)getValue(children.get(0));
				ArithExpr right = (ArithExpr)getValue(children.get(2));
				result = TestMain.context.mkAdd(left, right);
			} else if (children.get(1).getSymbol().equals(bg.addopMinus)){
				ArithExpr left = (ArithExpr)getValue(children.get(0));
				ArithExpr right = (ArithExpr)getValue(children.get(2));
				result = TestMain.context.mkSub(left, right);
			}
		} else if (symbol.equals(bg.ntE6)) {
			if(arg0.getChildren().size() == 2) {
				result = getValue(children.get(1));
			} else if (children.get(1).getSymbol().equals(bg.mulopMul)){
				ArithExpr left = (ArithExpr)getValue(children.get(0));
				ArithExpr right = (ArithExpr)getValue(children.get(2));
				result = TestMain.context.mkMul(left, right);
			} else if (children.get(1).getSymbol().equals(bg.mulopDiv)){
				ArithExpr left = (ArithExpr)getValue(children.get(0));
				ArithExpr right = (ArithExpr)getValue(children.get(2));
				result = TestMain.context.mkDiv(left, right);
			}
		} else if (symbol.equals(bg.ntE7)) {
			if(arg0.getChildren().get(0).getSymbol().equals(bg.exprJump7)) {
				result = getValue(children.get(1));
			} else if(children.get(0).getSymbol().equals(bg.unop)){
				result = TestMain.context.mkNot((BoolExpr) getValue(children.get(1)));
			}
		} else if (symbol.equals(bg.ntE8)) {
			if(arg0.getChildren().size() == 2) {
				result = getValue(children.get(1));
			} 
		} else if (symbol.equals(bg.ntE9)){
			if (children.get(0).getSymbol().equals(bg.int_)) {
				//	System.out.println("Flippin int "+getValue(children.get(0)));
				result = getValue(children.get(0));
			} else if (children.get(0).getSymbol().equals(bg.typeflag_int)) {
				//	result = getValue(children.get(2));
//					System.out.println("EID: "+extractVariable(children.get(1)));
				result = TestMain.context.mkIntConst(extractVariable(children.get(1)));
			} else if (children.get(0).getSymbol().equals(bg.typeflag_boolean)) {
//				System.out.println("EBOOL: "+extractVariable(children.get(1)));
				result = TestMain.context.mkBoolConst(extractVariable(children.get(1)));
			} else if(children.get(0).getSymbol().equals(bg.leftParanthesis) && children.get(2).getSymbol().equals(bg.rightParanthesis)){
				result = getValue(children.get(1));

					
										
																				result = TestMain.context.mkBoolConst(extractVariable(children.get(1)));
			} else {
				System.out.println("SiDECAR: Missing parsing for: "+children.get(0).getSymbol());
			}
		} else if (symbol.equals(bg.ntIdType)) {
			String varname = extractVariable(children.get(0));
			Expr intVar = TestMain.context.mkConst(varname, int_type); // TODO: change from intvar later to more general
			globalVariables.put(varname, intVar); // temp, stop treating everything as global TODO
//			System.out.println(varname+" registered as "+varname);
			result =  intVar;
		} else {
			System.out.println("[!!!Undefined visit: "+arg0.getSymbol()+"]");			
		}
		
		semaphore.release();
		return result;
	} 

}
